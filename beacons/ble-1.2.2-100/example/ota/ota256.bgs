# OTA example script
#
# This script is used to transfer image to internal flash
# After booting into DFU mode, bootloader reads flash contents and flashes
# contents to module
# 
#
# Example OTA service contains 2 characteristics
# - control point characteristic 
#      This is used to control Flashing procedure
#      Write request must be used to send commands, because some commands may take a while
#      to process.
# - data transfer characteristic
#      Firmware image is transferred through this characteristic
#      Use write command procedure to achieve faster image upload
#
#
# OTA Procedure:
# userdata region must be erased before uploading image
# - Upload Data
#    Use Write Commands to transfer firmware image to Data characteristic
#    NOTE! to simplify script data must be aligned to 256 byte boundaries
# - Flash Image
#    Boot device to DFU mode by writing 0x03 byte to control point

dim command
dim tmp(20)
dim channel
dim data_len
dim curr_connection
dim dfu_pointer  # current pointer to flash location to upload firmware
dim erase_page   # current page to erase
dim erase_flag   # flag to indicate if memory should be erased after disconnection
const max_erase_page = 64
const timer_erase = 1
dim a
# Flash retry counter
dim retry_counter
# Flash retry counter
dim max_retries

#init gap mode
event system_boot(major ,minor ,patch ,build ,ll_version ,protocol_version ,hw )
	
	#Set device to advertisement mode and allow undirected connections
	call gap_set_mode(2,2)
	
	# Initialize the DFU pointer
	dfu_pointer=0
end

event hardware_soft_timer(handle)
    if handle=timer_erase && erase_page < 64 then
        erase_page = erase_page + 1
        call hardware_set_soft_timer(200,0,1) # some random value less than 20ms to allow chaining page erases
        call flash_erase_page(erase_page)
    end if
end

# Incoming data event listener
# Handles OTA Control Point Attribute (commands) and OTA Data Attribute (firmware update) writes
# and performs the necessary actions
event attributes_value(connection, reason, handle, offset, value_len, value_data)
	
	#save connection handle, is always 0 if only slave
	curr_connection=connection

	# Check if OTA control point attribute is written by the remote device and execute the command
		# Command 0 : Erase flash block 0 (0x0-0x1FFFF)
		# Command 1 : Erase flash block 1 (0x10000-0x3FFFF)
		# Command 2 : Reset DFU data pointer
		# Command 3 : Boot to DFU mode
	# In case of errors application error code 0x80 is returned to the remote device
	# In case the flash comms fails error code 0x90 is returned to the remote device
    if handle = ota_control then
		#attribute is user attribute, reason is always write_request_user
		if value_len >1 || offset >0 then
			# Not a valid command -> report application error code : 0x80
			call attributes_user_write_response(connection, $80)
		else
			command=value_data(0:1)
			if command=0 then	# Command 0 received -> Erase block 0
                erase_page=0
                #erase_flag=1
				#start erase timer
				#call hardware_set_soft_timer(200,timer_erase,1)
                call attributes_user_write_response(curr_connection, 0)
			else
                if command=3 then # Command 3 received -> Boot to DFU mode 
                    call system_reset(1)
                end if
                
                if command<5 then #other commands not used
                    call attributes_user_write_response(curr_connection, $0)
                end if
            end if
			if command>4 then # Unknown command -> report application error code : 0x80
				call attributes_user_write_response(curr_connection, $80)
			end if
			
		end if
	end if
	
	# Check if OTA data attribute is written which carries the firmware update
	# and store the data to the internal flash
	if handle = ota_data then
        call flash_write_data(dfu_pointer,value_len,value_data(0:value_len))
        dfu_pointer = dfu_pointer + value_len
	end if
    
end

event attributes_user_read_request(connection, handle, offset, maxsize)
    call flash_read_data(offset, maxsize)(data_len, tmp(0:data_len))
    if data_len = 0 then
        #read is out of bounds
        call attributes_user_read_response(connection, $7, 0, tmp(0:1))
    else
        call attributes_user_read_response(connection, 0, data_len, tmp(0:data_len))
    end if
end

# Disconnection event handler 
# Makes the device visible and connectable
event connection_disconnected(handle,result)
	#in case if disconnect, return to advertisement mode
    call gap_set_mode(gap_general_discoverable,gap_undirected_connectable)
end
